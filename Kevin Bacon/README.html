<!DOCTYPE html>
<html>
<head>
<title>README.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h1 id="os-seis-graus-de-kevin-bacon">Os Seis Graus de Kevin Bacon</h1>
<p><em>Por João Felipe Ribeiro</em><br>
<em>24/11/2024</em>
<img src="image-1.png" alt="demo">
<sup><em>Exemplo uma saída do programa</em></sup></p>
<h2 id="introdu%C3%A7%C3%A3o">Introdução</h2>
<p>Os &quot;Seis Graus de Kevin Bacon&quot; são um conceito inspirado pela teoria dos &quot;seis graus de separação&quot;, que sugere que qualquer pessoa no mundo está conectada a qualquer outra por, no máximo, seis intermediários. Adaptado para o mundo do cinema, o jogo propõe que qualquer ator pode ser ligado a Kevin Bacon através de, no máximo, seis conexões baseadas em filmes em que atuaram juntos. Por exemplo, se o ator A trabalhou com o ator B em um filme, e B trabalhou com Kevin Bacon, então A tem um &quot;número de Bacon&quot; de 2. A ideia tornou-se um fenômeno cultural, enfatizando como as redes de colaboração no cinema (e na sociedade) são interconectadas.</p>
<h2 id="resumo">Resumo</h2>
<p>Na implementação da ideia as relações entre os atores pode ser descrita como um grafo não direcionado. A estrutura de dados interliga os atores ao seus filmes e outros atores, permitindo que um caminho seja traçado entre eles.</p>
<p><img src="image.png" alt="diagram">
<sup><em>Grafo não direcionado que interliga os filmes e os atores</em></sup></p>
<p>Para realizar a busca do caminho entre os atores, utiliza-se um algoritmo <strong>guloso</strong> para encontrar o primeiro melhor e mais curto caminho entre eles.</p>
<p>Para isso, é necessário utilizar uma variação do <strong>Breadth First Search</strong>, um algoritmo de pesquisa em largura para grafos. Nessa variação, é criado uma <strong>queue</strong> (fila) com todos os caminhos que foram percorridos. Se o caminho achado não for o caminho final entre os atores, a fila anda e um próximo caminho é analisado. Portanto o algoritmo é <strong>guloso</strong> pois ele sempre vai achar o <strong>primeiro</strong> caminho e o de menor tamanho (que é melhor para o caso).</p>
<h2 id="algoritmo-de-pesquisa-em-largura-breadth-first-search-algorithm">Algoritmo de Pesquisa em Largura (Breadth First Search Algorithm)</h2>
<p>Pseudo-código para o algoritmo utilizado:</p>
<pre class="hljs"><code><div>Função BFS(grafo, ator_inicial, ator_final):
    Se ator_final não estiver no grafo:
        Lançar erro: &quot;Esse ator não existe na base de dados&quot;

    Fila &lt;- []
    Inserir [ator_inicial] na Fila

    Enquanto a Fila não estiver vazia:
        Caminho &lt;- Remover o primeiro elemento da Fila
        Nodo &lt;- Último elemento do Caminho

        Se Nodo for igual a ator_final:
            Retornar Caminho

        Para cada adjacente em grafo[Nodo]:
            Novo_Caminho &lt;- Copiar Caminho
            Adicionar adjacente ao Novo_Caminho
            Inserir Novo_Caminho na Fila

    Retornar Nulo
</div></code></pre>
<h2 id="banco-tmdb">Banco TMDB</h2>
<p>Para implementar a utilização do banco de dados do TMDB, foi utilizado um arquivo csv contendo todos os dados dos filmes. Porém nem todos os dados são úteis para o projeto. Os únicos dados relevantes são os nomes dos filmes e dos atores. Portanto foi realizado uma filtragem para que fosse gerado um dicionário apenas com esses dados.</p>
<h2 id="construindo-o-grafo">Construindo o grafo</h2>
<p>A primeira etapa para construir o grafo é gerar um dicionário contendo uma relação filme:atores para cada item.</p>
<p>Percebe-se que a partir disso, temos um grafo <strong>direcionado</strong>. Ou seja, só existe a direção filmes para atores.</p>
<p>Em seguida, precisamos realizar a conversão desse grafo direcionado para um grafo indirecionado. Ou seja, precisamos de um grafo em que os filmes apontem para os atores, mas que os atores também apontem para os filmes.</p>
<p>Enfim, teremos um grafo não direcionado.</p>
<h2 id="renderizando-a-pesquisa">Renderizando a pesquisa</h2>
<p>Para escrever frases como &quot;Chris Evans trabalhou em Street Kings junto com Keanu Reeves&quot; foi criado um simples algoritmo que alterna entre conectivos para a frase de acordo com o índice do elemento do caminho do grafo.</p>

</body>
</html>
